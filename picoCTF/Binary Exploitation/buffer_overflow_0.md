# buffer overflow 0

## Challenge

Let's start off simple, can you overflow the correct buffer? The program is available here. You can view source here.

Additional details will be available after launching your challenge instance.

## Solving

Armed with my knowledge of the format string exploit, I look at the source code first this time.

```

#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
  printf("%s\n", flag);
  fflush(stdout);
  exit(1);
}

void vuln(char *input){
  char buf2[16];
  strcpy(buf2, input);
}

int main(int argc, char **argv){

  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }

  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler); // Set up signal handler

  gid_t gid = getegid();
  setresgid(gid, gid, gid);


  printf("Input: ");
  fflush(stdout);
  char buf1[100];
  gets(buf1);
  vuln(buf1);
  printf("The program will exit now\n");
  return 0;
}
```

The same exploit can be used here. The program takes an input into buf1, and then copies it into buf2. However, the size of buf1 is only 100, and the size of buf2 is only 16. If I input a string that is longer than 16 characters, it will overflow buf2 and cause a segmentation fault. OR, if i input a string that is longer than 100 characters, it will overflow buf1 and cause a segmentation fault. This segmentation fault is then caught by the signal function, Which prints out the flag.

what did i learn from this? gets is a dangerous function, and i should be using fgets instead. and from format string 0, using scanf is dangerous too, and we can instead use scanf with a buffer size limit , which was actually done in that challenge in the following manner:

```
    "Please choose from the following burgers:",
    "Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe",
    "Enter your recommendation: ");
```

